import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:hive_flutter/hive_flutter.dart';
import 'package:compareitr/core/common/entities/saved_entity.dart';
import 'package:compareitr/core/common/models/saved_model.dart';
import 'package:compareitr/core/error/exceptions.dart';
import 'package:compareitr/core/error/failures.dart';
import 'package:compareitr/core/common/cache/cache.dart';
import 'package:compareitr/features/saved/data/datasources/saved_remote_data_source.dart';
import 'package:compareitr/features/saved/domain/repository/saved_repository.dart';
import 'package:fpdart/fpdart.dart';

class SavedRepositoryImpl implements SavedRepository {
  final SavedRemoteDataSource remoteDataSource;

  SavedRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, SavedEntity>> addSavedItem({
    required String name,
    required String image,
    required String measure,
    required String shopName,
    required String savedId,
    required double price,
  }) async {
    try {
      // Call the remote data source directly with the required parameters
      await remoteDataSource.addSavedItem(
          name: name,
          image: image,
          measure: measure,
          shopName: shopName,
          savedId: savedId,
          price: price);

      // Return a new SavedEntity after successful addition.
      return right(SavedEntity(
          id: '', // The id will be generated by the database
          name: name,
          image: image,
          measure: measure,
          shopName: shopName,
          savedId: savedId,
          price: price));
    } on ServerException catch (e) {
      return left(Failure(e.message));
    } catch (e) {
      return left(Failure('Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> removeSavedItem(String id) async {
    try {
      await remoteDataSource.removeSavedItem(id);
      return right(null); // Return void on success.
    } on ServerException catch (e) {
      return left(Failure(e.message));
    } catch (e) {
      return left(Failure('Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, List<SavedEntity>>> getSavedItems(
      String savedId) async {
    try {
      // First, check for cached saved items
      final box = Hive.box('recently_viewed'); // Use the same box as recently viewed
      final cacheKey = 'saved_items_$savedId';
      final cachedData = box.get(cacheKey);
      
      if (cachedData != null) {
        final List<dynamic> cachedItems = List<dynamic>.from(cachedData);
        final savedEntities = cachedItems.map((item) {
          final itemData = Map<String, dynamic>.from(item as Map);
          return SavedModel(
            id: itemData['id'],
            name: itemData['name'],
            image: itemData['image'],
            measure: itemData['measure'],
            shopName: itemData['shopName'],
            savedId: itemData['savedId'],
            price: itemData['price'].toDouble(),
          );
        }).toList();
        
        if (savedEntities.isNotEmpty) {
          print('‚úÖ Using cached saved items (${savedEntities.length} items)');
          
          // If offline, always use cached data
          if (CacheManager.isOffline) {
            return right(savedEntities);
          }
          
          // If online, continue to fetch fresh data below
        }
      }

      // If offline and no cached saved items, return error
      if (CacheManager.isOffline) {
        return left(Failure('You\'re offline and no cached saved items available'));
      }

      // Fetch saved items from the remote data source
      final savedModels = await remoteDataSource.getSavedItems(savedId);

      // Convert SavedModel list to SavedEntity list.
      final savedEntities = savedModels.map((model) {
        return SavedModel(
          id: model.id, // Include the id from the fetched model
          name: model.name,
          image: model.image,
          measure: model.measure,
          shopName: model.shopName,
          savedId: model.savedId,
          price: model.price,
        );
      }).toList();

      // Cache the fresh data
      final cacheData = savedEntities.map((item) => {
        'id': item.id,
        'name': item.name,
        'image': item.image,
        'measure': item.measure,
        'shopName': item.shopName,
        'savedId': item.savedId,
        'price': item.price,
      }).toList();
      
      print('üîç Repository: Caching saved items data: ${cacheData.length} items');
      if (cacheData.isNotEmpty) {
        print('üîç Repository: First cached saved item: ${cacheData.first}');
      }
      
      box.put(cacheKey, cacheData);
      
      // Store saved item images in Hive for offline use (non-blocking)
      _storeSavedImagesInHive(savedEntities);
      
      print('‚úÖ Saved items: Cached ${savedEntities.length} items');
      return right(savedEntities);
    } on ServerException catch (e) {
      // If server error, try to use cached data as fallback
      final box = Hive.box('recently_viewed');
      final cacheKey = 'saved_items_$savedId';
      final cachedData = box.get(cacheKey);
      
      if (cachedData != null) {
        final List<dynamic> cachedItems = List<dynamic>.from(cachedData);
        final savedEntities = cachedItems.map((item) {
          final itemData = Map<String, dynamic>.from(item as Map);
          return SavedModel(
            id: itemData['id'],
            name: itemData['name'],
            image: itemData['image'],
            measure: itemData['measure'],
            shopName: itemData['shopName'],
            savedId: itemData['savedId'],
            price: itemData['price'].toDouble(),
          );
        }).toList();
        
        if (savedEntities.isNotEmpty) {
          print('‚úÖ Server error, using cached saved items: ${e.message}');
          return right(savedEntities);
        }
      }
      return left(Failure(e.message));
    } catch (e) {
      // Check if it's a network-related error
      final errorMessage = e.toString().toLowerCase();
      if (errorMessage.contains('socket') || errorMessage.contains('network') || errorMessage.contains('client')) {
        return left(Failure('Network connection error. Please check your internet connection.'));
      }
      return left(Failure('Unexpected error: $e'));
    }
  }

  // Store saved item images as base64 in Hive for offline persistence
  Future<void> _storeSavedImagesInHive(List<SavedEntity> savedItems) async {
    try {
      final box = Hive.box('recently_viewed');
      
      for (final item in savedItems) {
        final imageUrl = item.image;
        
        if (imageUrl.isNotEmpty) {
          try {
            // Download the image and convert to base64
            final response = await http.get(Uri.parse(imageUrl));
            if (response.statusCode == 200) {
              final base64Image = base64Encode(response.bodyBytes);
              final imageKey = 'savedImage_${item.name.hashCode}';
              await box.put(imageKey, base64Image);
              print('üíæ Stored saved item image: ${item.name}');
            }
          } catch (e) {
            print('‚ùå Failed to store saved item image ${item.name}: $e');
          }
        }
      }
    } catch (e) {
      print('‚ùå Error storing saved item images in Hive: $e');
    }
  }
}
