import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:hive_flutter/hive_flutter.dart';
import 'package:compareitr/core/common/entities/cart_entity.dart';
import 'package:compareitr/core/error/exceptions.dart';
import 'package:compareitr/core/error/failures.dart';
import 'package:compareitr/core/common/cache/cache.dart';
import 'package:compareitr/features/cart/data/datasources/cart_remote_data_source.dart';
import 'package:compareitr/features/cart/domain/repository/cart_repository.dart';
import 'package:fpdart/fpdart.dart';

class CartRepositoryImpl implements CartRepository {
  final CartRemoteDataSource remoteDataSource;

  CartRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, CartEntity>> addCartItem({
    required String cartId,
    required String itemName,
    required String shopName,
    required String imageUrl,
    required double price,
    required int quantity,
    required String measure,
  }) async {
    try {
      // Call the remote data source directly with the required parameters
      await remoteDataSource.addCartItem(
        cartId: cartId,
        itemName: itemName,
        shopName: shopName,
        imageUrl: imageUrl,
        price: price,
        quantity: quantity,
        measure: measure,
      );

      // Return a new CartEntity after successful addition.
      return right(CartEntity(
        id: '', // The id will be generated by the database
        cartId: cartId,
        itemName: itemName,
        shopName: shopName,
        price: price,
        quantity: quantity,
        imageUrl: imageUrl,
        measure: measure,
      ));
    } on ServerException catch (e) {
      return left(Failure(e.message));
    } catch (e) {
      return left(Failure('Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> removeCartItem(String id) async {
    try {
      await remoteDataSource.removeCartItem(id);
      return right(null); // Return void on success.
    } on ServerException catch (e) {
      return left(Failure(e.message));
    } catch (e) {
      return left(Failure('Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, List<CartEntity>>> getCartItems(String cartId) async {
    try {
      // First, check for cached cart items
      final box = Hive.box('recently_viewed'); // Use the same box as other cached data
      final cacheKey = 'cart_items_$cartId';
      final cachedData = box.get(cacheKey);
      
      if (cachedData != null) {
        final List<dynamic> cachedItems = List<dynamic>.from(cachedData);
        final cartEntities = cachedItems.map((item) {
          final itemData = Map<String, dynamic>.from(item as Map);
          return CartEntity(
            id: itemData['id'],
            cartId: itemData['cartId'],
            itemName: itemData['itemName'],
            shopName: itemData['shopName'],
            price: itemData['price'].toDouble(),
            quantity: itemData['quantity'],
            imageUrl: itemData['imageUrl'],
            measure: itemData['measure'],
          );
        }).toList();
        
        if (cartEntities.isNotEmpty) {
          print('‚úÖ Using cached cart items (${cartEntities.length} items)');
          
          // If offline, always use cached data
          if (CacheManager.isOffline) {
            return right(cartEntities);
          }
          
          // If online, continue to fetch fresh data below
        }
      }

      // If offline and no cached cart items, return error
      if (CacheManager.isOffline) {
        return left(Failure('You\'re offline and no cached cart items available'));
      }

      final cartModels = await remoteDataSource.getCartItems(cartId);

      // Convert CartModel list to CartEntity list.
      final cartEntities = cartModels.map((model) {
        return CartEntity(
          id: model.id,
          cartId: model.cartId,
          itemName: model.itemName,
          shopName: model.shopName,
          price: model.price,
          quantity: model.quantity,
          imageUrl: model.imageUrl,
          measure: model.measure,
        );
      }).toList();

      // Cache the fresh data
      final cacheData = cartEntities.map((item) => {
        'id': item.id,
        'cartId': item.cartId,
        'itemName': item.itemName,
        'shopName': item.shopName,
        'price': item.price,
        'quantity': item.quantity,
        'imageUrl': item.imageUrl,
        'measure': item.measure,
      }).toList();
      
      print('üîç Repository: Caching cart items data: ${cacheData.length} items');
      if (cacheData.isNotEmpty) {
        print('üîç Repository: First cached cart item: ${cacheData.first}');
      }
      
      box.put(cacheKey, cacheData);
      
      // Store cart item images in Hive for offline use (non-blocking)
      _storeCartImagesInHive(cartEntities);
      
      print('‚úÖ Cart: Cached ${cartEntities.length} cart items');
      return right(cartEntities);
    } on ServerException catch (e) {
      // If server error, try to use cached data as fallback
      final box = Hive.box('recently_viewed');
      final cacheKey = 'cart_items_$cartId';
      final cachedData = box.get(cacheKey);
      
      if (cachedData != null) {
        final List<dynamic> cachedItems = List<dynamic>.from(cachedData);
        final cartEntities = cachedItems.map((item) {
          final itemData = Map<String, dynamic>.from(item as Map);
          return CartEntity(
            id: itemData['id'],
            cartId: itemData['cartId'],
            itemName: itemData['itemName'],
            shopName: itemData['shopName'],
            price: itemData['price'].toDouble(),
            quantity: itemData['quantity'],
            imageUrl: itemData['imageUrl'],
            measure: itemData['measure'],
          );
        }).toList();
        
        if (cartEntities.isNotEmpty) {
          print('‚úÖ Server error, using cached cart items: ${e.message}');
          return right(cartEntities);
        }
      }
      return left(Failure(e.message));
    } catch (e) {
      // Check if it's a network-related error
      final errorMessage = e.toString().toLowerCase();
      if (errorMessage.contains('socket') || errorMessage.contains('network') || errorMessage.contains('client')) {
        return left(Failure('Network connection error. Please check your internet connection.'));
      }
      return left(Failure('Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> updateCartItem({
    required String cartId,
    required String id,
    required int quantity,
  }) async {
    try {
      // Call the remote data source to update the cart item
      await remoteDataSource.updateCartItem(
        cartId: cartId,
        id: id,
        quantity: quantity,
      );

      // Return void on success.
      return right(null);
    } on ServerException catch (e) {
      return left(Failure(e.message));
    } catch (e) {
      return left(Failure('Unexpected error: $e'));
    }
  }

  // Store cart item images as base64 in Hive for offline persistence
  Future<void> _storeCartImagesInHive(List<CartEntity> cartItems) async {
    try {
      final box = Hive.box('recently_viewed');
      
      for (final item in cartItems) {
        final imageUrl = item.imageUrl;
        
        if (imageUrl.isNotEmpty) {
          try {
            // Download the image and convert to base64
            final response = await http.get(Uri.parse(imageUrl));
            if (response.statusCode == 200) {
              final base64Image = base64Encode(response.bodyBytes);
              final imageKey = 'cartImage_${item.itemName.hashCode}';
              await box.put(imageKey, base64Image);
              print('üõí Stored cart item image: ${item.itemName}');
            }
          } catch (e) {
            print('‚ùå Failed to store cart item image ${item.itemName}: $e');
          }
        }
      }
    } catch (e) {
      print('‚ùå Error storing cart item images in Hive: $e');
    }
  }
}
